"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, Darlene Santes and <FULL NAME>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: drs4423
UT EID 2:
"""



def group_sum(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if start >= len(nums):
        return target == 0

    # next simplest case is when len = 1 and target is = 1
    # make decision
    target -= nums[start]

    # recursive call
    if group_sum(start + 1, nums, target):
        return True

    # undo the decision if not true
    target += nums[start]

    # Do not include the number
    return group_sum(start + 1, nums, target)



def group_sum_6(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target. Additionally, if there is are 6's present in the array, they must all
    be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # simplest case
    if start >= len(nums):
        return target == 0

    # next simplest case is when len = 1 and target is = 1
    # make decision
    target -= nums[start]

    # Forcing the inclusion of every instance of the number 6
    if nums[start] == 6:
        return group_sum_6(start + 1, nums, target)

    # recursive call
    if group_sum_6(start + 1, nums, target):
        return True

    # undo the decision if not true
    target += nums[start]

    # Do not include the number
    return group_sum_6(start + 1, nums, target)


def group_no_adj(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a value is chosen, the value immediately after
    (the value adjacent) cannot be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
     # simplest case
    if start >= len(nums):
        return target == 0

    # next simplest case is when len = 1 and target is = 1
    # make decision
    target -= nums[start]

    # recursive call, also skips the immediate next number
    if group_no_adj(start + 2, nums, target):
        return True


    # undo the decision if not true
    target += nums[start]

    # Do not include the number
    return group_no_adj(start + 1, nums, target)



def group_sum_5(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a multiple of 5 is in the array, it must be included
    If the value immediately following a multiple of 5 if 1, it must not be chosen

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # simplest case
    if start >= len(nums):
        return target == 0

    # next simplest case is when len = 1 and target is = 1
    # make decision
    target -= nums[start]

    # recursive call, checks if the number is a multiple of 5 and forces its inclusion
    if nums[start] == 5:
        # checks if the next number is 1 and skips it
        if nums[start + 1] == 1:
            return group_sum_5(start + 2, nums, target)
        # continues like normal if the next value is not 1
        return group_sum_5(start + 1, nums, target)

    if group_sum_5(start + 1, nums, target):
        return True

    # undo the decision if not true
    target += nums[start]

    # Do not include the number
    return group_sum_5(start + 1, nums, target)



def group_sum_clump(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if there is a group of identical numbers in succession,
    they must all be chosen, or none of them must be chosen.
    EX: [1, 2, 2, 2, 5, 2], all three of the middle 2's must be chosen, or none of them must be
    chosen to be included in the sum. One loop is allowed to check for identical numbers.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # base case
    if start >= len(nums):
        return target == 0

    # make a decision based on how many times this is included
    repeat_count = 0
    for i in range(start, len(nums)):
        if nums[start] == nums[i]:
            repeat_count += 1
        else:
            break

    # subtract total of all nums in the clump and then either include it or not
    clump_total = nums[start] * repeat_count
    target -= clump_total

    # Recursively call the function
    if group_sum_clump(start + repeat_count, nums, target):
        return True

    # Undo the action and move on
    target += clump_total

    # do not include the clump
    return group_sum_clump(start + repeat_count, nums, target)



def split_array(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    sum1 = 0
    sum2 = 0
    start_index = 0
    return successful_split(start_index, nums, sum1, sum2)

# this is the helper function for split_array
def successful_split(start_index, nums, sum1, sum2):
    """
    Recursively determines whether a list of integers can be split into two groups with equal sums

    Parameters
    ----------
    start_index : int
        The index in the list that we are trying to split into one list or another
    nums : list
        A list of integers to be split
    sum1 : int
        The sum of all ints in one subset
    sum2 : int
        The sum of all ints in the other subset

    Returns
    -------
    bool
        True if list can be split into subsets with equal sums, False otherwise
    """
    # base case
    if start_index >= len(nums):
        return sum1 == sum2

    # next best is adding number to sum 1 makes it == sum 2, so call function again and then undo it
    sum1 += nums[start_index]
    if successful_split(start_index + 1, nums, sum1, sum2):
        return True
    sum1 -= nums[start_index]

    # next best is adding num to sum2 makes it == sum1, so call function again
    sum2 += nums[start_index]
    return successful_split(start_index + 1, nums, sum1, sum2)



def split_odd_10(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of one group must be odd, while the other group must be a multiple of 10
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    start_index = 0
    sum1 = 0
    sum2 = 0
    return successful_odd_10(start_index, nums, sum1, sum2)


def successful_odd_10(start_index, nums, sum1, sum2):
    """
    Recursively determines whether a list of integers can be split into two groups with an odd sum 
    and a sum that is a multiple of 10

    Parameters
    ----------
    start_index : int
        The index in the list that we are trying to split into one list or another
    nums : list
        A list of integers to be split
    sum1 : int
        The sum of all ints in one subset, must be odd
    sum2 : int
        The sum of all ints in the other subset, must be a multiple of 10

    Returns
    -------
    bool
        True if the list can be split into subsets meeting the conditions, False otherwise
    """
    # base case is sum 1 is odd and sum 2 is multiple of 10
    if start_index >= len(nums):
        return sum1 % 2 == 1 and sum2 % 10 == 0

    # next best is adding a number to sum1 and meets requirements
    sum1 += nums[start_index]
    if successful_odd_10(start_index + 1, nums, sum1, sum2):
        return True
    # undo if not successful and try sum2, repeat
    sum1 -= nums[start_index]

    sum2 += nums[start_index]
    return successful_odd_10(start_index + 1, nums, sum1, sum2)



def split_53(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Additionally, all multiples of 5 must be in one group, and all multiples of 3 (and not 5)
    must be in the other group
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    start_index = 0
    sum1 = 0 # hold all multiples of 5
    sum2 = 0 # hold all multiple of 3

    return successful_53(nums, start_index, sum1, sum2)


def successful_53(nums, start_index, sum1, sum2):
    """ 
    Recursively determines whether a list of integers can be split into two groups with all 
    multiples of 5 in one subset and all multiples of 3 in another. Sums must be equal

    Parameters
    ----------
    start_index : int
        The index in the list that we are trying to split into one list or another
    nums : list
        A list of integers to be split
    sum1 : int
        Sum of one subset, which contains all multiples of 5
    sum2 : int
        Sum of one subset, which contains all multiples of 3 but not 5

    Returns
    -------
    bool
        True if list can be split into subsets with equal sums, False otherwise
    """
    # Base Case: both are equal, will handle multiples later
    if start_index >= len(nums):
        return sum1 == sum2

    # Next best case, multiple of 5 makes everything work out
    if nums[start_index] % 5 == 0:
        sum1 += nums[start_index]
        return successful_53(nums, start_index + 1, sum1, sum2)

    # Next next best, multiple of 3 makes everything work out
    if nums[start_index] % 3 == 0:
        sum2 += nums[start_index]
        return successful_53(nums, start_index + 1, sum1, sum2)

    # Next next next, all other nums start by trying to add to sum1
    sum1 += nums[start_index]
    if successful_split(start_index + 1, nums, sum1, sum2):
        return True
    sum1 -= nums[start_index]

    # next best is adding num to sum2 makes it == sum1, so call function again
    sum2 += nums[start_index]
    return successful_split(start_index + 1, nums, sum1, sum2)
